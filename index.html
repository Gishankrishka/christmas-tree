<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic 3D Tree - OK Gesture Zoom</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #ui { position: absolute; bottom: 5%; width: 100%; text-align: center; color: white; z-index: 10; pointer-events: none; }
        button { padding: 15px 40px; pointer-events: auto; cursor: pointer; background: #d32f2f; color: white; border: 2px solid #ffd700; border-radius: 50px; font-weight: bold; }
        #video-in { position: absolute; top: 10px; right: 10px; width: 150px; border-radius: 10px; transform: scaleX(-1); border: 2px solid rgba(255,255,255,0.3); }
        .guide { background: rgba(0,0,0,0.6); padding: 10px 20px; border-radius: 20px; display: inline-block; border: 1px solid #ffd700; }
    </style>
</head>
<body>

    <video id="video-in" autoplay playsinline></video>
    <div id="container"></div>

    <div id="ui">
        <div class="guide">
            üëå <b>D·∫•u OK:</b> Ph√≥ng to ·∫£nh g·∫ßn nh·∫•t | üñêÔ∏è <b>X√≤e tay:</b> N·ªï tung | ‚úä <b>N·∫Øm tay:</b> Thu v·ªÅ
        </div><br><br>
        <button id="startBtn">B·∫ÆT ƒê·∫¶U TR·∫¢I NGHI·ªÜM</button>
    </div>

    <audio id="music" loop>
        <source src="audio.mp3" type="audio/mpeg">
    </audio>

    <script>
        let scene, camera, renderer, hands, cameraFeed;
        let photoMeshes = [], magicDust, star;
        let state = 'TREE'; // TREE, EXPLODE, OK_ZOOM
        let handX = 0.5, handY = 0.5, okX = 0, okY = 0;
        let focusedMesh = null;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function initScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 2000);
            camera.position.z = 250;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 1));
            
            createStar(); // T·∫°o ng√¥i sao ƒë·ªânh c√¢y
            createMagicDust(); // T·∫°o b·ª•i √°nh s√°ng bay
            createForest(); // T·∫°o c√¢y th√¥ng ·∫£nh
            animate();
        }

        // T·∫°o ng√¥i sao 3D t·ª± quay (H√¨nh 1)
        function createStar() {
            const shape = new THREE.Shape();
            const points = 5;
            const outerRadius = 15;
            const innerRadius = 7;
            for (let i = 0; i < points * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = (i / points) * Math.PI;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) shape.moveTo(x, y);
                else shape.lineTo(x, y);
            }
            const extrudeSettings = { depth: 4, bevelEnabled: true, bevelThickness: 2, bevelSize: 2 };
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            const material = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.8, roughness: 0.2 });
            star = new THREE.Mesh(geometry, material);
            star.position.y = 85;
            scene.add(star);
        }

        function createMagicDust() {
            const dustGeo = new THREE.BufferGeometry();
            const dustPos = [];
            for(let i=0; i<3000; i++) dustPos.push((Math.random()-0.5)*800, (Math.random()-0.5)*800, (Math.random()-0.5)*800);
            dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(dustPos, 3));
            magicDust = new THREE.Points(dustGeo, new THREE.PointsMaterial({color: 0xFFD700, size: 1.5, transparent: true, opacity: 0.7}));
            scene.add(magicDust);
        }

        function createForest() {
            const geo = new THREE.PlaneGeometry(12, 16);
            for (let i = 1; i <= 31; i++) {
                const mat = new THREE.MeshBasicMaterial({ 
                    map: new THREE.TextureLoader().load(`public/photos/${i}.jpg`), 
                    side: THREE.DoubleSide, transparent: true, opacity: 0 
                });
                const mesh = new THREE.Mesh(geo, mat);
                
                const t = i / 31;
                const angle = i * 0.9;
                const radius = t * 65;
                mesh.userData.treePos = new THREE.Vector3(Math.cos(angle)*radius, (1-t)*130-60, Math.sin(angle)*radius);
                mesh.userData.explodePos = new THREE.Vector3((Math.random()-0.5)*450, (Math.random()-0.5)*450, (Math.random()-0.5)*350);
                
                mesh.position.copy(mesh.userData.treePos);
                scene.add(mesh);
                photoMeshes.push(mesh);
            }
        }

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                
                // NH·∫¨N DI·ªÜN C·ª¨ CH·ªà OK (Ng√≥n c√°i ch·∫°m ng√≥n tr·ªè)
                const distOK = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y, lm[4].z - lm[8].z);
                const isOK = distOK < 0.05; 
                const isFist = lm[12].y > lm[10].y && lm[16].y > lm[14].y && lm[8].y > lm[6].y;

                if (isOK) {
                    state = 'OK_ZOOM';
                    okX = (1 - lm[4].x) * 2 - 1; // T√¢m c·ªßa d·∫•u OK
                    okY = (1 - lm[4].y) * 2 - 1;
                } else if (isFist) {
                    state = 'TREE';
                } else {
                    state = 'EXPLODE';
                }

                handX = lm[9].x; handY = lm[9].y;
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            // Xoay ng√¥i sao ƒë·ªânh c√¢y t·ª± ƒë·ªông
            if (star) star.rotation.y += 0.05;

            // Camera follow tay
            camera.position.x += ((handX - 0.5) * 220 - camera.position.x) * 0.05;
            camera.position.y += ((0.5 - handY) * 120 - camera.position.y) * 0.05;
            camera.lookAt(0, 0, 0);

            // Raycaster t√¨m ·∫£nh g·∫ßn d·∫•u OK nh·∫•t
            if (state === 'OK_ZOOM') {
                mouse.set(okX, okY);
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(photoMeshes);
                focusedMesh = intersects.length > 0 ? intersects[0].object : null;
            } else {
                focusedMesh = null;
            }

            photoMeshes.forEach((mesh) => {
                const isTree = (state === 'TREE');
                const isFocus = (mesh === focusedMesh);
                const targetPos = isTree ? mesh.userData.treePos : mesh.userData.explodePos;
                
                if (isFocus) {
                    const zoomPos = new THREE.Vector3().lerpVectors(mesh.position, camera.position, 0.5);
                    mesh.position.lerp(zoomPos, 0.12);
                    mesh.rotation.y += 0.08; 
                    mesh.material.opacity = 1;
                    mesh.scale.lerp(new THREE.Vector3(2.2, 2.2, 2.2), 0.12);
                } else {
                    mesh.position.lerp(targetPos, 0.07);
                    const baseOpacity = isTree ? 0.15 : 1;
                    mesh.material.opacity += (baseOpacity - mesh.material.opacity) * 0.1;
                    mesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                    
                    if (isTree) mesh.lookAt(0, mesh.position.y, 0);
                    else { mesh.rotation.x += 0.01; mesh.rotation.y += 0.01; }
                }
            });

            if(magicDust) magicDust.rotation.y += 0.001;
            renderer.render(scene, camera);
        }

        function initMediaPipe() {
            hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6 });
            hands.onResults(onResults);
            cameraFeed = new Camera(document.getElementById('video-in'), {
                onFrame: async () => { await hands.send({ image: document.getElementById('video-in') }); },
                width: 640, height: 480
            });
            cameraFeed.start();
        }

        document.getElementById('startBtn').onclick = () => {
            document.getElementById('music').play(); // Ch·∫°y nh·∫°c Last Christmas
            document.getElementById('ui').style.display = 'none';
            initScene();
            initMediaPipe();
        };
    </script>
</body>
</html>
