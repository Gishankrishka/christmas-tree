<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic 3D Christmas - Intro Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #ui { position: absolute; bottom: 8%; width: 100%; text-align: center; color: white; z-index: 10; display: none; }
        #start-screen { position: absolute; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; color: white; }
        button { padding: 18px 45px; font-size: 20px; cursor: pointer; background: #ff0000; color: white; border: 2px solid #ffd700; border-radius: 50px; font-weight: bold; box-shadow: 0 0 20px gold; }
        #video-in { position: absolute; top: 15px; right: 15px; width: 130px; border-radius: 10px; transform: scaleX(-1); border: 2px solid gold; visibility: hidden; }
        .guide { background: rgba(0,0,0,0.8); padding: 12px 25px; border-radius: 30px; border: 1px solid #ffd700; }
        #intro-timer { position: absolute; top: 20px; left: 20px; color: gold; font-size: 14px; opacity: 0.7; }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1 style="color: gold; text-shadow: 0 0 10px gold;">K·ª∑ Ni·ªám Gi√°ng Sinh 2025</h1>
        <p style="margin-bottom: 30px; opacity: 0.8;">Nh·∫•n ƒë·ªÉ xem l·∫°i nh·ªØng kho·∫£nh kh·∫Øc v√† kh√°m ph√° ph√©p thu·∫≠t</p>
        <button id="startBtn">B·∫ÆT ƒê·∫¶U</button>
    </div>

    <div id="intro-timer"></div>
    <video id="video-in" autoplay playsinline></video>
    <div id="container"></div>

    <div id="ui">
        <div class="guide">üëå <b>D·∫•u OK:</b> Soi ·∫£nh | üñêÔ∏è <b>X√≤e tay:</b> N·ªï tung | ‚úä <b>N·∫Øm tay:</b> Thu v·ªÅ</div>
    </div>

    <audio id="music" loop><source src="audio.mp3" type="audio/mpeg"></audio>

    <script>
        let scene, camera, renderer, hands, cameraFeed, magicDust, starGroup;
        let photoMeshes = [];
        let state = 'INTRO'; 
        let handX = 0.5, handY = 0.5, okX = 0, okY = 0;
        let introIndex = 0, isIntroFinished = false;
        const totalPhotos = 31;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function initScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 2000);
            camera.position.z = 250;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 1.2));
            
            createGlowStar(); 
            createMagicDust();
            createForest();
            startIntroSequence();
            animate();
        }

        // T·∫°o ng√¥i sao m·ªù ·∫£o (Glow effect) b·∫±ng nhi·ªÅu l·ªõp Sprite
        function createGlowStar() {
            starGroup = new THREE.Group();
            const loader = new THREE.TextureLoader();
            // T·∫°o m·ªôt t√¢m s√°ng tr√≤n m·ªù
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255, 215, 0, 1)');
            grad.addColorStop(0.5, 'rgba(255, 215, 0, 0.3)');
            grad.addColorStop(1, 'rgba(255, 215, 0, 0)');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, 64, 64);
            
            const tex = new THREE.CanvasTexture(canvas);
            for(let i=0; i<3; i++) {
                const spriteMat = new THREE.SpriteMaterial({ map: tex, color: 0xffd700, transparent: true, opacity: 0.6 + i*0.1 });
                const sprite = new THREE.Sprite(spriteMat);
                sprite.scale.set(40 + i*10, 40 + i*10, 1);
                starGroup.add(sprite);
            }
            starGroup.position.y = 85;
            scene.add(starGroup);
        }

        function createMagicDust() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<4000; i++) pos.push((Math.random()-0.5)*1000, (Math.random()-0.5)*1000, (Math.random()-0.5)*1000);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            magicDust = new THREE.Points(geo, new THREE.PointsMaterial({color: 0xFFD700, size: 1.2, transparent: true, opacity: 0.8}));
            scene.add(magicDust);
        }

        function createForest() {
            const geo = new THREE.PlaneGeometry(12, 16);
            for (let i = 1; i <= totalPhotos; i++) {
                const mat = new THREE.MeshBasicMaterial({ 
                    map: new THREE.TextureLoader().load(`public/photos/${i}.jpg`), 
                    side: THREE.DoubleSide, transparent: true, opacity: 0 
                });
                const mesh = new THREE.Mesh(geo, mat);
                const t = i/31, a = i*0.9, r = t*65;
                mesh.userData.treePos = new THREE.Vector3(Math.cos(a)*r, (1-t)*130-60, Math.sin(a)*r);
                mesh.userData.explodePos = new THREE.Vector3((Math.random()-0.5)*400, (Math.random()-0.5)*400, (Math.random()-0.5)*300);
                mesh.userData.introActive = false;
                mesh.position.copy(mesh.userData.treePos);
                scene.add(mesh);
                photoMeshes.push(mesh);
            }
        }

        // Logic Intro t·ª± ƒë·ªông trong 30 gi√¢y
        function startIntroSequence() {
            let timeLeft = 30;
            const timerEl = document.getElementById('intro-timer');
            
            const interval = setInterval(() => {
                if(timeLeft <= 0) {
                    clearInterval(interval);
                    finishIntro();
                    return;
                }
                timerEl.innerText = `Ch·∫ø ƒë·ªô t·ª± ƒë·ªông: ${timeLeft}s`;
                
                // Ch·ªçn ·∫£nh ng·∫´u nhi√™n ƒë·ªÉ zoom v√†o gi·ªØa m√†n h√¨nh
                const rand = Math.floor(Math.random() * totalPhotos);
                photoMeshes.forEach(m => m.userData.introActive = false);
                photoMeshes[rand].userData.introActive = true;
                
                timeLeft -= 3;
            }, 3000);
        }

        function finishIntro() {
            state = 'EXPLODE';
            isIntroFinished = true;
            document.getElementById('intro-timer').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('video-in').style.visibility = 'visible';
            initMediaPipe();
        }

        function onResults(results) {
            if (!isIntroFinished || !results.multiHandLandmarks) return;
            const lm = results.multiHandLandmarks[0];
            const dx = lm[4].x - lm[8].x, dy = lm[4].y - lm[8].y;
            const isOK = Math.sqrt(dx*dx + dy*dy) < 0.08;
            const isFist = lm[12].y > lm[10].y && lm[8].y > lm[6].y;

            if (isOK) { state = 'OK_ZOOM'; okX = -(lm[4].x + lm[8].x) + 1; okY = -(lm[4].y + lm[8].y) + 1; }
            else if (isFist) state = 'TREE';
            else state = 'EXPLODE';
            
            handX = lm[9].x; handY = lm[9].y;
        }

        function animate() {
            requestAnimationFrame(animate);
            if (starGroup) starGroup.rotation.z += 0.01;
            magicDust.rotation.y += 0.0005;

            // Camera t·ª± ƒë·ªông xoay nh·∫π trong Intro, follow tay khi h·∫øt Intro
            if (!isIntroFinished) {
                camera.position.x = Math.sin(Date.now() * 0.0005) * 50;
            } else {
                camera.position.x += ((handX - 0.5) * 220 - camera.position.x) * 0.05;
                camera.position.y += ((0.5 - handY) * 120 - camera.position.y) * 0.05;
            }
            camera.lookAt(0, 0, 0);

            let currentFocus = null;
            if (state === 'OK_ZOOM') {
                mouse.set(okX, okY);
                raycaster.setFromCamera(mouse, camera);
                const hits = raycaster.intersectObjects(photoMeshes);
                if(hits.length > 0) currentFocus = hits[0].object;
            }

            photoMeshes.forEach((mesh) => {
                const isIntroZoom = mesh.userData.introActive && !isIntroFinished;
                const isUserZoom = mesh === currentFocus && state === 'OK_ZOOM';
                
                if (isIntroZoom || isUserZoom) {
                    const zoomDist = isIntroZoom ? 0.4 : 0.6;
                    const zoomPos = new THREE.Vector3().lerpVectors(mesh.position, camera.position, zoomDist);
                    mesh.position.lerp(zoomPos, 0.1);
                    mesh.scale.lerp(new THREE.Vector3(2.5, 2.5, 2.5), 0.1);
                    mesh.material.opacity = 1;
                    mesh.rotation.y += 0.05;
                } else {
                    const target = (state === 'TREE' && isIntroFinished) ? mesh.userData.treePos : mesh.userData.explodePos;
                    mesh.position.lerp(target, 0.06);
                    mesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                    const baseOp = (state === 'TREE' && isIntroFinished) ? 0.15 : 1;
                    mesh.material.opacity += (baseOp - mesh.material.opacity) * 0.1;
                    if (state === 'TREE') mesh.lookAt(0, mesh.position.y, 0);
                    else { mesh.rotation.x += 0.01; mesh.rotation.y += 0.01; }
                }
            });
            renderer.render(scene, camera);
        }

        function initMediaPipe() {
            hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6 });
            hands.onResults(onResults);
            cameraFeed = new Camera(document.getElementById('video-in'), {
                onFrame: async () => { await hands.send({ image: document.getElementById('video-in') }); },
                width: 640, height: 480
            });
            cameraFeed.start();
        }

        document.getElementById('startBtn').onclick = () => {
            document.getElementById('music').play();
            document.getElementById('start-screen').style.display = 'none';
            initScene();
        };
    </script>
</body>
</html>
